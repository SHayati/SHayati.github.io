var CryptoJS = require('crypto-js');
var elliptic = require('elliptic');
var EC = elliptic.ec;
var ec = new EC('secp256k1');


angular.module('cryptoApp', [])
    .controller('CryptoController', ['$scope', function ($scope) {
        // Import elliptic library
        var EC = elliptic.ec;
        var ec = new EC('secp256k1');

        var content = {
            en: {
                title: 'Cryptocurrency Web App',
                h1: 'Cryptocurrency Algorithms',
                section1: {
                    h2: 'SHA256',
                    p: 'Enter text to compute its SHA256 hash.',
                    label1: 'Input:',
                    button: 'Compute SHA256',
                    label2: 'Output:'
                },
                section2: {
                    h2: 'ECDSA Key Pair',
                    p: 'Generate a pair of ECDSA keys. These keys are called private and public keys. Transaction request on the network are digitally signed by private key. The actual identity of the person who has signed the transaction can later be verified by public. Public key also provide the Bitcoin adress which. For simplicity public key can be understood as account number and the validator of your messages in the public while the private key can serve as the password. Thus you can share the public key with the public, but you must keep your private key, of course private and strictly avoid revealing that.',
                    button: 'Generate Keys',
                    label1: 'Private Key:',
                    label2: 'Public Key:',
                    bitcoinAddress: 'Bitcoin address generated by pulblic key: '
                },
                section3: {
                    h2: 'ECDSA Digital Signature Verification',
                    p: 'Verify a digital signature using ECDSA keys. Expose your public key to the public.',
                    label1: 'Public Key:',
                    subsection: {
                        h3: 'Digitally sign a message:',
                        p: 'Write down a message you would like to sign it. Try to write down an imaginary transaction like you want send 1 satoshi (0.00000001 BTC) from your account to another account:',
                        label1: 'Message:',
                        label2: 'Private Key:',
                        p2: 'Here is the digital signature of the message signed by the previous private key:',
                        label3: 'Digital Signature:'
                    },
                    h3: 'Verify the digital signature using public key:',
                    p2: 'Now we shall verify the message and its signature against the exposed public key. The signiture will be verified only if it signed by the proper key:',
                    button: 'Verify Signature',
                    label4: 'Verification Result:'
                },
                p: 'The only person who knows the private key is you and thus you are the signature will be valid if it is isgned by you. This is why you have to keep the private key secure and avoid revel it to others. All the transactions on the blockchains are signed by their owners. You are the owner of your cryptocurrency and you are the only one who can sign a check to spend it, until you have your prvaite key secret'
            },
            fa: {
                // Persian content goes here...
            }
        };

        // Set default language
        $scope.content = content.en;

        $scope.setLanguage = function (lang) {
            $scope.content = content[lang];
        };

        // Section 1: SHA256
        $scope.computeSHA256 = function () {
            $scope.shaOutput = CryptoJS.SHA256($scope.shaInput).toString();
        };

        // Section 2: ECDSA Key Pair
        $scope.generateKeys = function () {
            var keys = ec.genKeyPair();
            $scope.ecdsaPrivate = keys.getPrivate('hex');
            $scope.ecdsaPublic = keys.getPublic('hex');

            // Hash the public key
            const publicKeyHash = CryptoJS.RIPEMD160(CryptoJS.SHA256($scope.ecdsaPublic).toString()).toString();

            // This is your Bitcoin address (account number)
            $scope.bitcoinAddress = `0x${publicKeyHash}`;

        };

        // Section 3: ECDSA Digital Signature
        $scope.digitalSignature = function () {
            var privateKey = ec.keyFromPrivate($scope.ecdsaVerifyPrivate);
            var msgHash = CryptoJS.SHA256($scope.ecdsaVerifyMessage);
            var signature = privateKey.sign(msgHash.toString(), 'hex');
            //$scope.ecdsaVerifySignatureR = signature.r.toString(16);
            //$scope.ecdsaVerifySignatureS = signature.s.toString(16);
            $scope.ecdsaVerifySignature = signature.r.toString(16) + '\n' + signature.s.toString(16);
        };

        $scope.$watch('ecdsaVerifyMessage', function (newVal, oldVal) {
            if (newVal !== oldVal) {
                $timeout.cancel($scope.digitalSignaturePromise); // Cancel previous timeout if it exists
                $scope.digitalSignaturePromise = $timeout($scope.digitalSignature, 1000); // Start a new timeout
            }
        });
        // Section 5: ECDSA Digital Signature Verification
        $scope.verifySignature = function () {
            try {

                var publicKey = ec.keyFromPublic($scope.ecdsaVerifyPublic, 'hex');
                var msgHash = CryptoJS.SHA256($scope.ecdsaVerifyMessage);
                //var signature = { r: $scope.ecdsaVerifySignatureR, s: $scope.ecdsaVerifySignatureS };
                var aa = $scope.ecdsaVerifySignature.split('\n');
                if (aa.length != 2) {
                    $scope.ecdsaVerifyResult = 'Invalid Signature';
                    $scope.ecdsaVerifyResultColor = 'red';
                    return;
                }
                var signature = { r: $scope.ecdsaVerifySignature.split('\n')[0], s: $scope.ecdsaVerifySignature.split('\n')[1] };
                $scope.ecdsaVerifyResult = publicKey.verify(msgHash.toString(), signature) ? 'Valid Signature' : 'Invalid  Signature';
                $scope.ecdsaVerifyResultColor = $scope.ecdsaVerifyResult === 'Valid Signature' ? 'green' : 'red';
            } catch (error) {
                $scope.ecdsaVerifyResult = 'Invalid Signature';
                $scope.ecdsaVerifyResultColor = 'red';
            }

        };
    }]);
